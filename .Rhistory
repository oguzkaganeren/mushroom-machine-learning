levels(mushroom$stalk_color_below_ring) <- c("buff", "cinnamon", "red", "gray", "brown", "pink",
"green", "purple", "white", "yellow")
levels(mushroom$veil_color) <- c("brown", "orange", "white", "yellow")
levels(mushroom$ring_number) <- c("none", "one", "two")
levels(mushroom$ring_type) <- c("evanescent", "flaring", "large", "none", "pendant")
levels(mushroom$spore_print_color) <- c("buff", "chocolate", "black", "brown", "orange",
"green", "purple", "white", "yellow")
levels(mushroom$population) <- c("abundant", "clustered", "numerous", "scattered", "several", "solitary")
levels(mushroom$habitat) <- c("wood", "grasses", "leaves", "meadows", "paths", "urban", "waste")
map_dbl(mushroom, function(.x) {sum(is.na(.x))})
##
mushroom <- read.csv("agaricus-lepiota.csv",header = TRUE) # load dataset
#replace NA values to columns mode
Mode <- function (x, na.rm) {
xtab <- table(x)
xmode <- names(which(xtab == max(xtab)))
if (length(xmode) > 1) xmode <- ">1 mode"
return(xmode)
}
for (var in 1:ncol(mushroom)) {
mushroom[is.na(mushroom[,var]),var] <- Mode(mushroom[,var], na.rm = TRUE)
}
#after data preparation of missing values.
missmap(mushroom, main = "After data preparation of missing values")
#after data preparation of missing values.
missmap(mushroom, main = "After data preparation of missing values")
mushroom <- read.csv("agaricus-lepiota.csv",header = TRUE) # load dataset
#replace NA values to columns mode
Mode <- function (x, na.rm) {
xtab <- table(x)
xmode <- names(which(xtab == max(xtab)))
if (length(xmode) > 1) xmode <- ">1 mode"
return(xmode)
}
for (var in 1:ncol(mushroom)) {
mushroom[is.na(mushroom[,var]),var] <- Mode(mushroom[,var], na.rm = TRUE)
}
#after data preparation of missing values.
missmap(mushroom, main = "After data preparation of missing values")
ComputeProportion <- function(target,attribute_dataset,Columns,centroid){
len_attr <- length(Columns)
RMSE <- NULL
for(i in 1:len_attr){
tab <- table(target,attribute_dataset[,Columns[i]])
prop <- tab[2,]/(tab[1,]+tab[2,])
centr_prop <- prop - centroid
Err <- sqrt(mean(centr_prop*centr_prop))
RMSE <-rbind(RMSE,Err)
}
norm_err <- (RMSE-min(RMSE))/(max(RMSE)-min(RMSE))
err_mat <- cbind(colnames(mushroom[,Columns]),RMSE)
err_mat <- cbind(err_mat,norm_err)
colnames(err_mat) <- c("Column name","RMSE","Norm. Error")
err_mat
}
proportions_tab <- ComputeProportion(mushroom[,1],mushroom,c(2:23),0.482)
print(proportions_tab)
#stalk_shape ve veil_type en dÃ¼ÅŸÃ¼k deÄŸere sahip
drops <- c("veil_type") #there is one unique values of veil_type, stalk_shape we can remove this column in our dataset.
mushroom <- mushroom[ , !(names(mushroom) %in% drops)] #remove veil_type,stalk_shape
# remove unncessary data
rm(drops)
mushroom <- mushroom %>% map_df(function(.x) as.factor(.x))
## We redefine each of the category for each of the variables
levels(mushroom$class) <- c("edible", "poisonous")
levels(mushroom$cap_shape) <- c("bell", "conical", "flat", "knobbed", "sunken", "convex")
levels(mushroom$cap_color) <- c("buff", "cinnamon", "red", "gray", "brown", "pink",
"green", "purple", "white", "yellow")
levels(mushroom$cap_surface) <- c("fibrous", "grooves", "scaly", "smooth")
levels(mushroom$bruises) <- c("no", "yes")
levels(mushroom$odor) <- c("almond", "creosote", "foul", "anise", "musty", "none", "pungent", "spicy", "fishy")
levels(mushroom$gill_attachment) <- c("attached", "free")
levels(mushroom$gill_spacing) <- c("close", "crowded")
levels(mushroom$gill_size) <- c("broad", "narrow")
levels(mushroom$gill_color) <- c("buff", "red", "gray", "chocolate", "black", "brown", "orange",
"pink", "green", "purple", "white", "yellow")
levels(mushroom$stalk_shape) <- c("enlarging", "tapering")
levels(mushroom$stalk_root) <- c("missing", "bulbous", "club", "equal", "rooted")
levels(mushroom$stalk_surface_above_ring) <- c("fibrous", "silky", "smooth", "scaly")
levels(mushroom$stalk_surface_below_ring) <- c("fibrous", "silky", "smooth", "scaly")
levels(mushroom$stalk_color_above_ring) <- c("buff", "cinnamon", "red", "gray", "brown", "pink",
"green", "purple", "white", "yellow")
levels(mushroom$stalk_color_below_ring) <- c("buff", "cinnamon", "red", "gray", "brown", "pink",
"green", "purple", "white", "yellow")
levels(mushroom$veil_color) <- c("brown", "orange", "white", "yellow")
levels(mushroom$ring_number) <- c("none", "one", "two")
levels(mushroom$ring_type) <- c("evanescent", "flaring", "large", "none", "pendant")
levels(mushroom$spore_print_color) <- c("buff", "chocolate", "black", "brown", "orange",
"green", "purple", "white", "yellow")
levels(mushroom$population) <- c("abundant", "clustered", "numerous", "scattered", "several", "solitary")
levels(mushroom$habitat) <- c("wood", "grasses", "leaves", "meadows", "paths", "urban", "waste")
map_dbl(mushroom, function(.x) {sum(is.na(.x))})
##
mushroom <- read.csv("agaricus-lepiota.csv",header = TRUE) # load dataset
#replace NA values to columns mode
Mode <- function (x, na.rm) {
xtab <- table(x)
xmode <- names(which(xtab == max(xtab)))
if (length(xmode) > 1) xmode <- ">1 mode"
return(xmode)
}
for (var in 1:ncol(mushroom)) {
mushroom[is.na(mushroom[,var]),var] <- Mode(mushroom[,var], na.rm = TRUE)
}
#after data preparation of missing values.
missmap(mushroom, main = "After data preparation of missing values")
ComputeProportion <- function(target,attribute_dataset,Columns,centroid){
len_attr <- length(Columns)
RMSE <- NULL
for(i in 1:len_attr){
tab <- table(target,attribute_dataset[,Columns[i]])
prop <- tab[2,]/(tab[1,]+tab[2,])
centr_prop <- prop - centroid
Err <- sqrt(mean(centr_prop*centr_prop))
RMSE <-rbind(RMSE,Err)
}
norm_err <- (RMSE-min(RMSE))/(max(RMSE)-min(RMSE))
err_mat <- cbind(colnames(mushroom[,Columns]),RMSE)
err_mat <- cbind(err_mat,norm_err)
colnames(err_mat) <- c("Column name","RMSE","Norm. Error")
err_mat
}
#install.packages("Amelia")
#install.packages("caret")
library(arm)
library(caret)
library(purrr)
library(Amelia)
library(pROC)
source(file = "Preparation.R") # just shows worked dataset after data preparation.
library(ggplot2)
ggplot(mushroom, aes(x = cap_surface, y = cap_color, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("green", "red"))
ggplot(mushroom, aes(x = cap_shape, y = cap_color, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("green", "red"))
ggplot(mushroom, aes(x = gill_color, y = cap_color, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("green", "red"))
ggplot(mushroom, aes(x = class, y = odor, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("green", "red"))
set.seed(579642)  #Set the seed for reproducibility
train_index <- sample(1:nrow(mushroom), size=nrow(mushroom)*0.8) # randomly choice rows
data_train  <- mushroom[train_index,]
data_test   <- mushroom[-train_index,]
trControl <- trainControl(method = "cv", number = 10, search = "grid")
############################# for ntree
## k fold cross validation takes too much time. So that, We optimize the 1-4 ntree.
start_time <- Sys.time()
ntreeAccuracy <- list()
for(i in c(1:20)){
set.seed(579642)
rf_ntree <- train(class~.,
data = data_train,
method = "rf",
metric = "Accuracy",
trControl = trControl,
ntree = i)
current_iteration <- toString(i)
ntreeAccuracy[[current_iteration]] <- mean(rf_ntree$results$Accuracy)
}
print(ntreeAccuracy)
plot(unlist(ntreeAccuracy), type="o" , bty="l" , ylab="Accuracy" , xlab="ntreeValues" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
meanNtreeAccuracy <- lapply(ntreeAccuracy, mean)
ntreeMax <- which.max(as.vector(unlist(meanNtreeAccuracy)))
### mtry value continue as 1 after the 6.
tuneGrid <- expand.grid(.mtry = c(1: 6))
rf_mtry <- train(class~.,
data = data_train,
method = "rf",
metric = "Accuracy",
tuneGrid = tuneGrid,
trControl = trControl,
do.trace = TRUE, ## is given about of randomForest.
ntree = ntreeMax)
print(rf_mtry)
plot(rf_mtry, type="o" , bty="l" , ylab="Accuracy" , xlab="mtry Values" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
rf_mtry$results$Accuracy
mean(rf_mtry$results$Accuracy)
tuneGrid <- expand.grid(.mtry = rf_mtry$bestTune$mtry )
AccuracyList <- c()
RecallList <- c()
F_ScoreList <- c()
PrecisionList <- c()
store_maxnode <- list()
indexes <- c()
for (maxnodes in c(5: 15)) {
set.seed(579642)
rf_maxnode <- train(class~.,
data = data_train,
method = "rf",
metric = "Accuracy",
trControl = trControl,
tuneGrid = tuneGrid,
importance = TRUE,
nodesize = 14,
maxnodes = maxnodes,
ntree = ntreeMax)
current_iteration <- toString(maxnodes)
store_maxnode[[current_iteration]] <- rf_maxnode$results$Accuracy
indexes <- c(indexes,maxnodes)
print(maxnodes)
prediction <-predict(rf_maxnode, data_test)
confusion_matrix <- confusionMatrix(prediction, data_test$class)
confusion_matrix
TP <- confusion_matrix$table[2,2]
TN <- confusion_matrix$table[1,1]
FP <- confusion_matrix$table[2,1]
FN <- confusion_matrix$table[1,2]
Accuracy <- (TP+TN)/(TP+TN+FP+FN)
AccuracyList <- c(AccuracyList,Accuracy)
Recall <- TP/(TP+FN)
RecallList <- c(RecallList,Recall)
F_Score <- 2*TP/(2*TP+FP+FN)
F_ScoreList <- c(F_ScoreList , F_Score )
Precision <- TP/(TP+FP)
PrecisionList <- c(PrecisionList , Precision )
}
AccuracyList
RecallList
F_ScoreList
PrecisionList
plot(AccuracyList, type="o" , bty="l" , xlab="maxNodeValues" , ylab="Accuracy" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
plot(RecallList, type="o" , bty="l" , xlab="maxNodeValues" , ylab="RecallList" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
plot(F_ScoreList, type="o" , bty="l" , xlab="maxNodeValues" , ylab="F_ScoreList" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
plot(PrecisionList, type="o" , bty="l" , xlab="maxNodeValues" , ylab="PrecisionList" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
mean(AccuracyList)
mean(RecallList)
mean(F_ScoreList)
mean(PrecisionList)
meanMaxnodesAccuracies <- lapply(store_maxnode, mean)
maxnodes <- which.max(as.vector(unlist(meanMaxnodesAccuracies)))
maxAccuracy <- max(as.vector(unlist(meanMaxnodesAccuracies)))
maxnodes <- indexes[maxnodes]
end_time <- Sys.time()
print(paste("running time => ", (end_time-start_time)))
## end.
## end.
## end.
plot(AccuracyList, type="o" , bty="l" , xlab="maxNodeValues" , ylab="Accuracy" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
plot(AccuracyList, type="o" , bty="l" , xlab="maxNodeValues" , ylab="Accuracy" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
plot(RecallList, type="o" , bty="l" , xlab="maxNodeValues" , ylab="RecallList" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
plot(F_ScoreList, type="o" , bty="l" , xlab="maxNodeValues" , ylab="F_ScoreList" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
plot(PrecisionList, type="o" , bty="l" , xlab="maxNodeValues" , ylab="PrecisionList" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
plot(unlist(ntreeAccuracy), type="o" , bty="l" , ylab="Accuracy" , xlab="ntreeValues" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
ggplot(mushroom, aes(x = cap_surface, y = cap_color, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("blue", "yellow"))
ggplot(mushroom, aes(x = cap_surface, y = cap_color, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("magenta", "yellow"))
ggplot(mushroom, aes(x = cap_surface, y = cap_color, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("darkblue", "yellow"))
ggplot(mushroom, aes(x = cap_surface, y = cap_color, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("darkblue", "red"))
ggplot(mushroom, aes(x = cap_surface, y = cap_color, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("darkblue", "dimgray"))
ggplot(mushroom, aes(x = gill_color, y = cap_color, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("brown", "slateblue1"))
ggplot(mushroom, aes(x = cap_surface, y = cap_color, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("darkblue", "dimgray"))
ggplot(mushroom, aes(x = cap_shape, y = cap_color, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("coral1", "skyblue1"))
ggplot(mushroom, aes(x = gill_color, y = cap_color, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("brown", "slateblue1"))
ggplot(mushroom, aes(x = class, y = odor, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("ivory", "goldenrod"))
ggplot(mushroom, aes(x = class, y = odor, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("chocalate", "dimgray"))
ggplot(mushroom, aes(x = class, y = odor, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("chocolate", "dimgray"))
ggplot(mushroom, aes(x = gill_color, y = cap_color, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("brown", "slateblue1"))
ggplot(mushroom, aes(x = cap_shape, y = cap_color, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("coral1", "skyblue1"))
ggplot(mushroom, aes(x = cap_shape, y = cap_color, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("sienna4", "skyblue1"))
ggplot(mushroom, aes(x = cap_surface, y = cap_color, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("darkblue", "dimgray"))
ggplot(mushroom, aes(x = cap_shape, y = cap_color, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("sienna4", "skyblue1"))
library(ggplot2)
ggplot(mushroom, aes(x = cap_surface, y = cap_color, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("darkblue", "dimgray"))
ggplot(mushroom, aes(x = cap_shape, y = cap_color, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("sienna4", "skyblue1"))
ggplot(mushroom, aes(x = gill_color, y = cap_color, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("brown", "slateblue1"))
ggplot(mushroom, aes(x = class, y = odor, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("chocolate", "dimgray"))
View(data_train)
#install.packages("Amelia")
#install.packages("caret")
library(arm)
library(caret)
library(purrr)
library(Amelia)
library(pROC)
source(file = "Preparation.R") # just shows worked dataset after data preparation.
library(ggplot2)
ggplot(mushroom, aes(x = cap_surface, y = cap_color, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("darkblue", "dimgray"))
ggplot(mushroom, aes(x = cap_shape, y = cap_color, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("sienna4", "skyblue1"))
ggplot(mushroom, aes(x = gill_color, y = cap_color, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("brown", "slateblue1"))
ggplot(mushroom, aes(x = class, y = odor, col = class)) +
geom_jitter(alpha = 0.5) +
scale_color_manual(breaks = c("edible", "poisonous"),
values = c("chocolate", "dimgray"))
set.seed(579642)  #Set the seed for reproducibility
train_index <- sample(1:nrow(mushroom), size=nrow(mushroom)*0.8) # randomly choice rows
data_train  <- mushroom[train_index,]
data_test   <- mushroom[-train_index,]
trControl <- trainControl(method = "cv", number = 10, search = "grid")
############################# for ntree
## k fold cross validation takes too much time. So that, We optimize the 1-4 ntree.
start_time <- Sys.time()
ntreeAccuracy <- list()
for(i in c(1:20)){
set.seed(579642)
rf_ntree <- train(bruises~.,
data = data_train,
method = "rf",
metric = "Accuracy",
trControl = trControl,
ntree = i)
current_iteration <- toString(i)
ntreeAccuracy[[current_iteration]] <- mean(rf_ntree$results$Accuracy)
}
print(ntreeAccuracy)
plot(unlist(ntreeAccuracy), type="o" , bty="l" , ylab="Accuracy" , xlab="ntreeValues" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
meanNtreeAccuracy <- lapply(ntreeAccuracy, mean)
ntreeMax <- which.max(as.vector(unlist(meanNtreeAccuracy)))
############################# for mtry.
### mtry value continue as 1 after the 6.
tuneGrid <- expand.grid(.mtry = c(1: 6))
rf_mtry <- train(bruises~.,
data = data_train,
method = "rf",
metric = "Accuracy",
tuneGrid = tuneGrid,
trControl = trControl,
do.trace = TRUE, ## is given about of randomForest.
ntree = ntreeMax)
print(rf_mtry)
plot(rf_mtry, type="o" , bty="l" , ylab="Accuracy" , xlab="mtry Values" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
rf_mtry$results$Accuracy
mean(rf_mtry$results$Accuracy)
tuneGrid <- expand.grid(.mtry = rf_mtry$bestTune$mtry )
############################# for maxnode
AccuracyList <- c()
RecallList <- c()
F_ScoreList <- c()
PrecisionList <- c()
store_maxnode <- list()
indexes <- c()
for (maxnodes in c(5: 15)) {
set.seed(579642)
rf_maxnode <- train(bruises~.,
data = data_train,
method = "rf",
metric = "Accuracy",
trControl = trControl,
tuneGrid = tuneGrid,
importance = TRUE,
nodesize = 14,
maxnodes = maxnodes,
ntree = ntreeMax)
current_iteration <- toString(maxnodes)
store_maxnode[[current_iteration]] <- rf_maxnode$results$Accuracy
indexes <- c(indexes,maxnodes)
print(maxnodes)
prediction <-predict(rf_maxnode, data_test)
confusion_matrix <- confusionMatrix(prediction, data_test$bruises)
confusion_matrix
TP <- confusion_matrix$table[2,2]
TN <- confusion_matrix$table[1,1]
FP <- confusion_matrix$table[2,1]
FN <- confusion_matrix$table[1,2]
Accuracy <- (TP+TN)/(TP+TN+FP+FN)
AccuracyList <- c(AccuracyList,Accuracy)
Recall <- TP/(TP+FN)
RecallList <- c(RecallList,Recall)
F_Score <- 2*TP/(2*TP+FP+FN)
F_ScoreList <- c(F_ScoreList , F_Score )
Precision <- TP/(TP+FP)
PrecisionList <- c(PrecisionList , Precision )
}
AccuracyList
RecallList
F_ScoreList
PrecisionList
plot(AccuracyList, type="o" , bty="l" , xlab="maxNodeValues" , ylab="Accuracy" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
plot(RecallList, type="o" , bty="l" , xlab="maxNodeValues" , ylab="RecallList" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
plot(F_ScoreList, type="o" , bty="l" , xlab="maxNodeValues" , ylab="F_ScoreList" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
plot(PrecisionList, type="o" , bty="l" , xlab="maxNodeValues" , ylab="PrecisionList" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
mean(AccuracyList)
mean(RecallList)
mean(F_ScoreList)
mean(PrecisionList)
meanMaxnodesAccuracies <- lapply(store_maxnode, mean)
maxnodes <- which.max(as.vector(unlist(meanMaxnodesAccuracies)))
maxAccuracy <- max(as.vector(unlist(meanMaxnodesAccuracies)))
maxnodes <- indexes[maxnodes]
end_time <- Sys.time()
print(paste("running time => ", (end_time-start_time)))
## end.
View(data_train)
plot(AccuracyList, type="o" , bty="l" , xlab="maxNodeValues" , ylab="Accuracy" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
plot(AccuracyList, type="o" , bty="l" , xlab="maxNodeValues" , ylab="Accuracy" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
plot(RecallList, type="o" , bty="l" , xlab="maxNodeValues" , ylab="RecallList" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
plot(F_ScoreList, type="o" , bty="l" , xlab="maxNodeValues" , ylab="F_ScoreList" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
plot(PrecisionList, type="o" , bty="l" , xlab="maxNodeValues" , ylab="PrecisionList" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
mean(AccuracyList)
mean(RecallList)
mean(F_ScoreList)
mean(PrecisionList)
plot(AccuracyList, type="o" , bty="l" , xlab="maxNodeValues" , ylab="Accuracy" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
plot(RecallList, type="o" , bty="l" , xlab="maxNodeValues" , ylab="RecallList" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
plot(F_ScoreList, type="o" , bty="l" , xlab="maxNodeValues" , ylab="F_ScoreList" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
plot(PrecisionList, type="o" , bty="l" , xlab="maxNodeValues" , ylab="PrecisionList" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
plot(rf_mtry, type="o" , bty="l" , ylab="Accuracy" , xlab="mtry Values" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
plot(unlist(ntreeAccuracy), type="o" , bty="l" , ylab="Accuracy" , xlab="ntreeValues" , col=rgb(0.1,0.5,0.1,0.8) , lwd=0.5 , pch=16  )
confusion_matrix
store_maxnode <- list()
indexes <- c()
for (maxnodes in c(5: 15)) {
set.seed(579642)
rf_maxnode <- train(class~.,
data = data_train,
method = "rf",
metric = "Accuracy",
trControl = trControl,
tuneGrid = tuneGrid,
importance = TRUE,
nodesize = 14,
maxnodes = maxnodes,
ntree = ntreeMax)
current_iteration <- toString(maxnodes)
store_maxnode[[current_iteration]] <- rf_maxnode$results$Accuracy
indexes <- c(indexes,maxnodes)
print(maxnodes)
prediction <-predict(rf_maxnode, data_test)
confusion_matrix <- confusionMatrix(prediction, data_test$class)
confusion_matrix
TP <- confusion_matrix$table[2,2]
TN <- confusion_matrix$table[1,1]
FP <- confusion_matrix$table[2,1]
FN <- confusion_matrix$table[1,2]
Accuracy <- (TP+TN)/(TP+TN+FP+FN)
AccuracyList <- c(AccuracyList,Accuracy)
Recall <- TP/(TP+FN)
RecallList <- c(RecallList,Recall)
F_Score <- 2*TP/(2*TP+FP+FN)
F_ScoreList <- c(F_ScoreList , F_Score )
Precision <- TP/(TP+FP)
PrecisionList <- c(PrecisionList , Precision )
}
confusion_matrix
